## VectorChord 源码学习: 6 使用指南（Usage Guide）  
                                                  
### 作者                                                  
digoal                                                  
                                                  
### 日期                                                  
2025-11-01                                                  
                                                  
### 标签                                                  
VectorChord , 源码学习                                                  
                                                  
----                                                  
                                                  
## 背景                        
本文介绍在生产环境中使用 **VectorChord** 的实用说明，涵盖从安装、创建索引、执行查询到性能优化的完整工作流。    
  
## 安装与设置  
  
**VectorChord** 依赖 **pgvector** 扩展，并必须通过 `shared_preload_libraries` 加载，以确保正确初始化。  
  
### Docker 安装（推荐）  
```  
-- Start PostgreSQL with VectorChord  
docker run --name vectorchord-demo \  
  -e POSTGRES_PASSWORD=mysecretpassword \  
  -p 5432:5432 \  
  -d ghcr.io/tensorchord/vchord-postgres:pg18-v0.5.3  
```  
  
### 扩展激活  
```  
-- Enable VectorChord (automatically loads pgvector as dependency)  
CREATE EXTENSION IF NOT EXISTS vchord CASCADE;  
```  
  
使用 `CASCADE` 选项可确保先安装 **pgvector**。初始化过程会注册 GUC 参数、索引访问方法（index access methods）以及查询采样钩子（query sampling hooks），详见 [`src/index/gucs.rs` 86-261](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L86-L261)。  
  
来源:    
[`README.md` 65-87](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L65-L87)    
[`src/sql/finalize.sql` 1-435](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L1-L435)  
  
  
  
## 基本使用工作流  
  
![pic](20251101_10_pic_001.jpg)  
  
**基本使用工作流**：该图展示了用户从建表到查询执行与监控的典型流程，并引用了内部代码实体。工作流说明了在索引创建和查询执行期间，PostgreSQL 如何调用索引访问方法的回调函数（如 `ambuild`、`amrescan`、`amgettuple`）。  
  
来源:    
[`README.md` 85-122](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L85-L122)    
[`src/sql/finalize.sql` 224-314](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L224-L314)    
[`src/index/functions.rs` 44-63](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/functions.rs#L44-L63)  
  
  
  
## 数据类型与向量表示  
  
**VectorChord** 支持多种向量表示形式，具有不同的精度和存储特性：  
  
| 数据类型（Data Type） | 描述（Description） | 来源类型（Source Type） | 存储效率（Storage Efficiency） |  
|---|---|---|---|  
| `vector(N)` | **pgvector** 的全精度类型 | pgvector | 基准（每维 4 字节） |  
| `halfvec(N)` | **pgvector** 的半精度浮点（FP16） | pgvector | 小 2 倍（每维 2 字节） |  
| `scalar8(N)` | **VectorChord** 的 8 位量化类型 | VectorChord | 小 4 倍（每维 1 字节） |  
| `sphere_vector` | 复合类型：(中心向量, 半径 real) | VectorChord | 用于范围查询（range queries） |  
| `sphere_halfvec` | 复合类型：(中心 halfvec, 半径 real) | VectorChord | 半精度球体 |  
| `sphere_scalar8` | 复合类型：(中心 scalar8, 半径 real) | VectorChord | 量化球体 |  
  
`scalar8` 类型通过内部重排序（re-ranking）在显著节省存储的同时保持可接受的召回率（recall）。可使用 `quantize_to_scalar8()` 函数转换现有向量，详见 [`src/sql/finalize.sql` 139-143](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L139-L143)。  
  
### 量化示例（Quantization Example）  
```  
-- Convert vector to scalar8 for 4x storage reduction  
SELECT quantize_to_scalar8('[1.0, 2.5, 3.7]'::vector);  
  
-- Create sphere for range queries  
SELECT sphere('[1.0, 2.0, 3.0]'::vector, 0.5);  
```  
  
来源:    
[`src/sql/finalize.sql` 3-28](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L3-L28)    
[`src/sql/finalize.sql` 130-143](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L130-L143)  
  
  
  
## 创建表与索引  
  
### 表创建  
```  
-- Basic table with vector column  
CREATE TABLE documents (  
    id BIGSERIAL PRIMARY KEY,  
    embedding vector(768),  
    content TEXT  
);  
  
-- Table with multiple vector types  
CREATE TABLE multimodal_data (  
    id BIGSERIAL PRIMARY KEY,  
    text_embedding vector(768),  
    image_embedding halfvec(512),  
    quantized_embedding scalar8(384)  
);  
  
-- Table for multi-vector retrieval (MaxSim)  
CREATE TABLE documents_multi (  
    id BIGSERIAL PRIMARY KEY,  
    token_embeddings vector(768)[]  
);  
```  
  
### 索引类型选择  
  
![pic](20251101_10_pic_002.jpg)  
  
**索引类型选择决策树**：该图根据数据集特征和需求指导索引类型选择。    
- `vchordrq` 方法（通过 `vchordrq_amhandler` 在 [`src/sql/finalize.sql` 224]() 注册）适用于大数据集和内存受限场景；    
- `vchordg` 方法（通过 `vchordg_amhandler` 在 [`src/sql/finalize.sql` 303]() 注册）在小数据集上提供更低延迟。  
  
来源:    
[`README.md` 96-122](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L96-L122)    
[`src/sql/finalize.sql` 311-413](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L311-L413)    
[`scripts/index.py` 79-118](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/index.py#L79-L118)  
  
### 索引创建语法  
  
#### `vchordrq` 索引（推荐用于大数据集）  
```  
-- Default build (single centroid, simplest)  
CREATE INDEX ON documents USING vchordrq (embedding vector_l2_ops);  
  
-- Internal build with K-means clustering  
CREATE INDEX ON documents USING vchordrq (embedding vector_l2_ops)  
WITH (options = $$  
    [build.internal]  
    lists = [1000]  
    build_threads = 8  
    spherical_centroids = false  
    residual_quantization = true  
$$);  
  
-- External build with pre-computed centroids (see section below)  
CREATE INDEX ON documents USING vchordrq (embedding vector_ip_ops)  
WITH (options = $$  
    [build.external]  
    table = 'public.documents_centroids'  
$$);  
```  
  
#### `vchordg` 索引（基于图结构，graph-based）  
```  
-- Graph index with default parameters  
CREATE INDEX ON documents USING vchordg (embedding vector_l2_ops);  
```  
  
操作符类（operator class）（如 `vector_l2_ops`、`vector_ip_ops`、`vector_cosine_ops`）必须与查询中使用的距离度量（distance metric）匹配。    
- `vchordrq` 访问方法处理器在 [`src/sql/finalize.sql` 224-225](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L224-L225) 注册；    
- `vchordg` 在 [`src/sql/finalize.sql` 303-304](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L303-L304) 注册。  
  
来源:    
[`README.md` 96-100](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L96-L100)    
[`scripts/index.py` 79-118](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/index.py#L79-L118)    
[`src/sql/finalize.sql` 311-413](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L311-L413)  
  
  
  
## 距离操作符与查询模式  
  
### 标准距离操作符  
  
| 操作符（Operator） | 距离度量（Distance Metric） | 操作符类（Operator Class） | SQL 函数 | 使用场景（Use Case） |  
|---|---|---|---|---|  
| `<->` | L2（欧氏距离，Euclidean） | `vector_l2_ops` | `_vchord_scalar8_operator_l2`（[`finalize.sql` 33]()） | 通用相似性 |  
| `<#>` | 内积（Inner Product，点积） | `vector_ip_ops` | `_vchord_scalar8_operator_ip`（[`finalize.sql` 40]()） | 归一化向量、嵌入（embeddings） |  
| `<=>` | 余弦距离（Cosine Distance） | `vector_cosine_ops` | `_vchord_scalar8_operator_cosine`（[`finalize.sql` 47]()） | 方向相似性 |  
| `<<->>` | 向量到球体的 L2 距离 | `vector_l2_ops` | `_vchord_vector_sphere_l2_in`（[`finalize.sql` 54]()） | 范围查询 |  
| `<<#>>` | 向量到球体的内积 | `vector_ip_ops` | `_vchord_vector_sphere_ip_in`（[`finalize.sql` 75]()） | 范围查询 |  
| `<<=>>` | 向量到球体的余弦距离 | `vector_cosine_ops` | `_vchord_vector_sphere_cosine_in`（[`finalize.sql` 96]()） | 范围查询 |  
| `@#` | MaxSim（最大相似度） | `vector_maxsim_ops` | `_vchord_vector_operator_maxsim`（[`finalize.sql` 117]()） | 多向量检索 |  
  
这些操作符在 [`src/sql/finalize.sql` 32-127](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L32-L127) 中定义，并为每种数据类型（`vector`、`halfvec`、`scalar8`）提供了对应的 PGRX 包装函数。  
  
### 基本查询模式  
```  
-- K-nearest neighbors search  
SELECT id, content, embedding <-> '[0.1, 0.2, ...]'::vector AS distance  
FROM documents  
ORDER BY embedding <-> '[0.1, 0.2, ...]'::vector  
LIMIT 10;  
  
-- With WHERE clause (prefilter controlled by vchordrq.prefilter GUC)  
SET vchordrq.prefilter = true;  -- gucs.rs:70  
SELECT id, content  
FROM documents  
WHERE category = 'science'  
ORDER BY embedding <-> '[0.1, 0.2, ...]'::vector  
LIMIT 10;  
  
-- Range query using sphere (operator defined in finalize.sql:53-72)  
SELECT id, content  
FROM documents  
WHERE embedding <<->> sphere('[0.1, 0.2, ...]'::vector, 0.5)  
ORDER BY embedding <-> '[0.1, 0.2, ...]'::vector  
LIMIT 100;  
  
-- Multi-vector retrieval (MaxSim operator at finalize.sql:116-127)  
SELECT id, token_embeddings @# ARRAY[  
    '[0.1, 0.2, ...]'::vector,  
    '[0.3, 0.4, ...]'::vector  
] AS score  
FROM documents_multi  
ORDER BY token_embeddings @# ARRAY[  
    '[0.1, 0.2, ...]'::vector,  
    '[0.3, 0.4, ...]'::vector  
]  
LIMIT 10;  
```  
  
**查询执行流程**：当 PostgreSQL 执行这些查询时，会调用索引访问方法的 `amrescan()` 初始化扫描器，然后反复调用 `amgettuple()` 获取结果。    
- `vchordrq` 扫描器使用 `LazyCell` 迭代器模式，将昂贵操作延迟到真正需要时执行；    
- 对于标准相似度操作符，创建 `DefaultSearchBuilder`；    
- 对于 MaxSim 操作符，创建 `MaxsimSearchBuilder`。  
  
来源:    
[`README.md` 102-121](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L102-L121)    
[`src/sql/finalize.sql` 32-127](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L32-L127)    
[`src/index/gucs.rs` 70](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L70-L70)  
  
  
  
## 配置参数概览  
  
**VectorChord** 提供两组 GUC（Grand Unified Configuration，统一配置）参数，用于控制索引行为。所有参数均通过 `GucRegistry::define_*_guc()` 调用在 [`src/index/gucs.rs` 86-261](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L86-L261) 中注册。  
  
### `vchordrq` 配置参数  
  
| 参数（Parameter） | 类型（Type） | 默认值（Default） | GUC 定义位置 | 描述（Description） |  
|---|---|---|---|---|  
| `vchordrq.enable_scan` | bool | true | [`gucs.rs` 87-94]() | 启用/禁用索引扫描（通过 `vchordrq_enable_scan()` 访问） |  
| `vchordrq.probes` | string | `""` | [`gucs.rs` 95-102]() | 每层 IVF 树的探针数（由 `vchordrq_probes()` 在 [`gucs.rs` 302]() 解析） |  
| `vchordrq.epsilon` | float | 1.9 | [`gucs.rs` 103-112]() | 重排序过采样因子（通过 `vchordrq_epsilon()` 在 [`gucs.rs` 330]() 访问） |  
| `vchordrq.max_scan_tuples` | int | -1 | [`gucs.rs` 113-122]() | 限制扫描元组数（-1 表示无限制） |  
| `vchordrq.prefilter` | bool | false | [`gucs.rs` 143-150]() | 在索引扫描前应用 WHERE 子句（通过 `vchordrq_prefilter()` 在 [`gucs.rs` 347]() 访问） |  
| `vchordrq.maxsim_refine` | int | 0 | [`gucs.rs` 123-132]() | MaxSim 优化迭代次数 |  
| `vchordrq.maxsim_threshold` | int | 0 | [`gucs.rs` 133-142]() | MaxSim 提前终止阈值 |  
| `vchordrq.io_search` | enum | `read_stream`（PG17+） | [`gucs.rs` 151-158]() | I/O 策略：`read_buffer`、`prefetch_buffer`、`read_stream`（PostgresIo 枚举见 [`gucs.rs` 19]()） |  
| `vchordrq.io_rerank` | enum | `read_stream`（PG17+） | [`gucs.rs` 159-166]() | 重排序阶段的 I/O 策略 |  
  
#### 查询采样参数（需超级用户权限，`GucContext::Suset`）  
  
| 参数 | 类型 | 默认值 | GUC 定义位置 | 描述 |  
|---|---|---|---|---|  
| `vchordrq.query_sampling_enable` | bool | false | [`gucs.rs` 167-174]() | 启用查询采样到 SQLite |  
| `vchordrq.query_sampling_max_records` | int | 0 | [`gucs.rs` 175-184]() | 每个索引最大记录数（0 表示无限制） |  
| `vchordrq.query_sampling_rate` | float | 0.0 | [`gucs.rs` 185-194]() | 采样概率（0.0–1.0） |  
  
### `vchordg` 配置参数  
  
| 参数 | 类型 | 默认值 | GUC 定义位置 | 描述 |  
|---|---|---|---|---|  
| `vchordg.enable_scan` | bool | true | [`gucs.rs` 201-208]() | 启用/禁用索引扫描 |  
| `vchordg.ef_search` | int | 64 | [`gucs.rs` 209-218]() | HNSW 搜索广度（通过 `vchordg_ef_search()` 在 [`gucs.rs` 267]() 访问） |  
| `vchordg.beam_search` | int | 1 | [`gucs.rs` 219-228]() | 图遍历的束宽（beam width） |  
| `vchordg.max_scan_tuples` | int | -1 | [`gucs.rs` 229-238]() | 限制扫描元组数 |  
| `vchordg.io_search` | enum | `read_stream`（PG17+） | [`gucs.rs` 239-246]() | 搜索阶段的 I/O 策略 |  
| `vchordg.io_rerank` | enum | `read_stream`（PG17+） | [`gucs.rs` 247-254]() | 重排序阶段的 I/O 策略 |  
  
  
  
### 配置示例  
```  
-- Adjust vchordrq search parameters (parsed by vchordrq_probes() at gucs.rs:302-328)  
SET vchordrq.probes = '100';  -- Single-level: use 100 probes  
SET vchordrq.probes = '100,200';  -- Multi-level: 100 probes at level 0, 200 at level 1  
SET vchordrq.epsilon = 1.5;  -- Retrieved by vchordrq_epsilon() at gucs.rs:330-332  
  
-- Adjust vchordg search parameters (retrieved by vchordg_ef_search() at gucs.rs:267-269)  
SET vchordg.ef_search = 128;  
SET vchordg.beam_search = 2;  
  
-- Disable index scan for exact search (checked by vchordrq_enable_scan() at gucs.rs:298-300)  
SET vchordrq.enable_scan = false;  
SELECT * FROM documents ORDER BY embedding <-> '[...]'::vector LIMIT 10;  
  
-- Enable query sampling (Suset context, requires superuser or pg_reload_conf())  
ALTER SYSTEM SET vchordrq.query_sampling_enable = on;  
SELECT pg_reload_conf();  
```  
  
  
`probes` 参数可接受单个整数（应用于所有树层级）或逗号分隔的列表（用于多层 IVF 树）。解析逻辑在 [`src/index/gucs.rs` 302-328](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L302-L328) 中，通过遍历字节处理数字和逗号，转换为 `Vec<u32>`。  
  
  
来源:    
[`src/index/gucs.rs` 30-380](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L30-L380)    
[`scripts/bench.py` 77-81](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L77-L81)  
  
  
  
## 外部索引预计算工作流  
  
**VectorChord** 支持使用外部预计算的聚类中心（centroids）构建索引，从而实现 GPU 加速的 K-means 训练，并处理超出 PostgreSQL 内存限制的大型数据集。  
  
![pic](20251101_10_pic_003.jpg)  
  
### 外部索引预计算工作流  
  
该图展示使用外部聚类中心构建索引的三阶段流程，支持 GPU 加速和超大内存数据集处理。  
  
#### 工作流步骤  
  
**步骤 1：从 PostgreSQL 导出向量**    
  
```  
python scripts/dump.py \  
  -n documents \  
  -c embedding \  
  -d 768 \  
  -o export.hdf5 \  
  --url postgresql://user:pass@localhost:5432/dbname  
```  
  
`dump.py` 脚本使用 `psycopg` 通过游标迭代将向量流式写入 HDF5 文件（[`scripts/dump.py` 54-73](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/dump.py#L54-L73)）。  
  
**步骤 2：训练 K-means 聚类中心**    
  
```  
# CPU training for small datasets (1M-5M vectors)  
python scripts/train.py \  
  -i export.hdf5 \  
  -o centroids.npy \  
  --lists 1000 \  
  -m l2  
  
# GPU training for large datasets (5M-100M vectors)  
python scripts/train.py \  
  -i export.hdf5 \  
  -o centroids.npy \  
  --lists 4000 \  
  -m l2 \  
  -g --mmap  
```  
  
`train.py` 脚本使用 **FAISS** 进行 K-means 聚类。对于大数据集，推荐的 `lists` 参数范围为 `4*sqrt(N)` 到 `16*sqrt(N)`（[`scripts/README.md` 42-46](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L42-L46)）。  
  
**步骤 3：使用外部聚类中心构建索引**    
  
```  
python scripts/index.py \  
  -n documents \  
  -i export.hdf5 \  
  -c centroids.npy \  
  -m l2 \  
  -d 768 \  
  -w 8 \  
  --url postgresql://user:pass@localhost:5432/dbname  
```  
  
`index.py` 脚本在 PostgreSQL 中创建聚类中心表，并使用外部构建策略创建索引（[`scripts/index.py` 132-148](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/index.py#L132-L148)、[`scripts/index.py` 176-188](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/index.py#L176-L188)）。  
  
  
来源:    
[`scripts/README.md` 1-59](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L1-L59)    
[`scripts/dump.py` 1-82](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/dump.py#L1-L82)    
[`scripts/index.py` 1-248](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/index.py#L1-L248)  
  
  
  
## 查询采样与召回率监控  
  
**VectorChord** 内置查询采样系统，用于在生产环境中监控索引性能。启用后，会将查询向量记录到本地 SQLite 数据库供后续分析。  
  
### 启用查询采样  
```  
-- Configure query sampling (requires superuser, GucContext::Suset)  
ALTER SYSTEM SET vchordrq.query_sampling_enable = on;  
ALTER SYSTEM SET vchordrq.query_sampling_max_records = 1000;  
ALTER SYSTEM SET vchordrq.query_sampling_rate = 0.1;  -- 10% sampling rate  
SELECT pg_reload_conf();  
```  
  
采样系统通过 GUC 注册在 [`src/index/gucs.rs` 167-194](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L167-L194) 中初始化，并在 [`src/recorder/worker.rs` 1-148](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/recorder/worker.rs#L1-L148) 中实现。启用后，系统会：  
  
- 1、在查询执行期间调用 `vchordrq_query_sampling_enable()`（[`gucs.rs` 369-371]()）；  
- 2、根据 `vchordrq_query_sampling_rate()`（[`gucs.rs` 377-379]()）决定是否采样；  
- 3、通过 `push()` 函数（[`worker.rs` 74-105]()）存储查询向量；  
- 4、存储路径为 `pgsql_tmp_vchord_sampling/database_{oid}.sqlite`（[`worker.rs` 21, 41]()）；  
- 5、每个索引对应一个表 `index_{index_oid}`，包含字段 `sample TEXT, create_at REAL`（[`worker.rs` 81]()）；  
- 6、当记录数超过 `vchordrq_query_sampling_max_records()`（[`gucs.rs` 373-375]()）时，自动删除最旧条目（[`worker.rs` 88-99]()）。  
  
目录名 `pgsql_tmp_vchord_sampling` 以 `pgsql_tmp` 开头，确保被 `pg_basebackup` 排除（[`worker.rs` 20-21]()）。  
  
来源:    
[`src/index/gucs.rs` 167-194](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L167-L194)    
[`src/index/gucs.rs` 369-379](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L369-L379)    
[`src/recorder/worker.rs` 20-122](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/recorder/worker.rs#L20-L122)  
  
### 查看采样查询  
```  
-- View all sampled queries across all indexes  
SELECT * FROM vchordrq_sampled_queries;  
  
-- View sampled queries for specific index  
SELECT * FROM vchordrq_sampled_queries('my_index'::regclass);  
```  
  
**查询采样架构**：  
  
![pic](20251101_10_pic_004.jpg)  
  
`vchordrq_sampled_queries` 视图在 [`src/sql/finalize.sql` 417-435](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L417-L435) 中定义为 PL/pgSQL 函数，其功能包括：  
  
- 1、查询 `pg_catalog.pg_class` 以查找所有 `vchordrq` 索引（[`finalize.sql` 427-433]()）；  
- 2、对每个索引调用 `vchordrq_sampled_queries(regclass)` 函数（[`finalize.sql` 148-222]()）；  
- 3、调用 C 函数 `_vchordrq_sampled_values()`（[`finalize.sql` 145-146]()）；  
- 4、通过 `dump()` 函数（[`src/recorder/worker.rs` 124-147](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/recorder/worker.rs#L124-L147)）执行 `SELECT sample FROM index_{index} ORDER BY create_at DESC`（[`worker.rs` 129]()）。  
  
来源:    
[`src/sql/finalize.sql` 145-222](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L145-L222)    
[`src/sql/finalize.sql` 417-435](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L417-L435)    
[`src/recorder/worker.rs` 74-147](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/recorder/worker.rs#L74-L147)  
  
### 评估召回率（Recall）  
```  
-- Evaluate recall for a sampled query  
SELECT vchordrq_evaluate_query_recall(  
    query => 'SELECT ctid FROM documents ORDER BY embedding <-> ''[...]'' LIMIT 10'  
);  
  
-- Evaluate with exact ground truth (disables vchordrq index)  
SELECT vchordrq_evaluate_query_recall(  
    query => 'SELECT ctid FROM documents ORDER BY embedding <-> ''[...]'' LIMIT 10',  
    exact_search => true  
);  
  
-- Evaluate with custom accuracy parameters  
SELECT vchordrq_evaluate_query_recall(  
    query => 'SELECT ctid FROM documents ORDER BY embedding <-> ''[...]'' LIMIT 10',  
    accu_probes => '65535',  
    accu_epsilon => 1.9  
);  
```  
  
**召回率评估流程 (Recall Evaluation Process)**  ([`finalize.sql` 230-301]())：  
1.  执行粗略查询 (Execute rough query): 使用当前参数运行查询, 捕获 ctid 数组 ([`finalize.sql` 260-266]())  
2.  执行精确查询 (Execute accurate query), 使用以下方式之一：  
    * 精确搜索 (Exact search): `SET LOCAL vchordrq.enable_scan = off` 以强制顺序扫描 (sequential scan) ([`finalize.sql` 270]())  
    * 高精度 (High-accuracy): `SET LOCAL vchordrq.probes = {accu_probes}` 和 `SET LOCAL vchordrq.epsilon = {accu_epsilon}` ([`finalize.sql` 281-283]())  
    * 默认精度参数 (Default accuracy parameters): `probes = '65535,65535'` 或 `'65535'`, `epsilon = 1.9` ([`finalize.sql` 272-279]())  
3.  捕获精确结果 (Capture accurate results): 再次执行查询, 捕获基准真相 (ground truth) ctid 数组 ([`finalize.sql` 285-289]())  
4.  计算召回率 (Compute recall): `SELECT COUNT(*) FROM (SELECT unnest(rough) INTERSECT SELECT unnest(accu))` ([`finalize.sql` 297]())  
5.  返回比率 (Return ratio): `recall = match_count / accu_k` ([`finalize.sql` 298]())  
  
该函数处理边缘情况 (edge cases)：  
* MaxSim 操作符需要 `exact_search => true` ([`finalize.sql` 250-252]())  
* 空结果集返回 `NaN` ([`finalize.sql` 293-295]())  
* 带有有用错误信息的错误处理 (Error handling) ([`finalize.sql` 264-266](), [`289-291`]())  
  
来源:    
[`src/sql/finalize.sql` 230-301](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L230-L301)    
[`tests/vchordrq/recall.slt` 1-182](https://github.com/tensorchord/VectorChord/blob/ac12e257/tests/vchordrq/recall.slt#L1-L182)  
  
#### 批量召回率评估  
```  
-- Evaluate average recall across all sampled queries for an index  
SELECT AVG(recall_value) AS avg_recall  
FROM (  
    SELECT vchordrq_evaluate_query_recall(  
        query => format(  
            'SELECT ctid FROM %I.%I ORDER BY %I OPERATOR(%s) %L LIMIT 10',  
            sq.schema_name,  
            sq.table_name,  
            sq.column_name,  
            sq.operator,  
            sq.value  
        )  
    ) AS recall_value  
    FROM vchordrq_sampled_queries('my_index'::regclass) AS sq  
) AS eval_results;  
```  
  
来源:    
[`src/sql/finalize.sql` 145-301](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L145-L301)    
[`src/recorder/worker.rs` 74-105](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/recorder/worker.rs#L74-L105)    
[`tests/vchordrq/recall.slt` 1-182](https://github.com/tensorchord/VectorChord/blob/ac12e257/tests/vchordrq/recall.slt#L1-L182)  
  
  
  
## 索引维护操作  
  
### 预热索引（Pre-warming Indexes）  
  
预热操作将索引页加载到 PostgreSQL 缓冲区缓存中，以减少冷启动延迟。  
  
```  
-- Pre-warm entire vchordrq index (all tree levels)  
SELECT vchordrq_prewarm('documents_embedding_idx'::regclass);  
  
-- Pre-warm specific height levels (0 = all, positive = specific height)  
SELECT vchordrq_prewarm('documents_embedding_idx'::regclass, 2);  
  
-- Pre-warm vchordg index  
SELECT vchordg_prewarm('documents_embedding_idx'::regclass);  
```  
  
**预热实现 (Pre-warming Implementation)**  ([`functions.rs` 22-63]())：  
1.  验证索引 (Validate index): 查询 `PgAm::search_amname()` 和 `PgClass::search_reloid()` 以验证索引存在且类型正确 ([`functions.rs` 23-36]() (vchordg), [`45-58`]() (vchordrq))  
2.  打开索引 (Open index): 调用 `pgrx::pg_sys::index_open(indexrelid, AccessShareLock)` 以获取共享锁 (shared lock) ([`functions.rs` 71-75]())  
3.  获取操作符族 (Get opfamily): 检索用于分发 (dispatch) 的操作符族 (operator family) ([`functions.rs` 38]() (vchordg), [`60`]() (vchordrq))  
4.  创建 PostgresRelation (Create PostgresRelation): 将原始关系指针 (raw relation pointer) 包装在安全的 Rust 类型中 ([`functions.rs` 39, 61]())  
5.  分发到实现 (Dispatch to implementation): 调用 `vchordg::dispatch::prewarm()` 或 `vchordrq::dispatch::prewarm()` ([`functions.rs` 40, 62]())  
6.  迭代页面 (Iterate pages): 实现 (Implementation) 顺序读取索引页面 (index pages), 强制缓冲区管理器 (buffer manager) 将它们加载到缓存 (cache) 中  
7.  释放锁 (Release lock): `Drop` 实现 (impl) 调用 `pgrx::pg_sys::index_close()` ([`functions.rs` 84-87]())  
  
`Index` 包装结构体（[`functions.rs` 65-88]()）通过 RAII 模式确保即使发生错误也能正确释放锁。  
  
来源:    
[`src/index/functions.rs` 22-88](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/functions.rs#L22-L88)    
[`README.md` 117](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L117-L117)  
  
### 监控索引构建进度  
  
在并行索引构建期间，可使用 PostgreSQL 内置视图监控进度。  
  
```  
-- Monitor index build progress  
SELECT   
    relname,  
    phase,  
    blocks_done,  
    blocks_total,  
    tuples_done,  
    tuples_total  
FROM pg_stat_progress_create_index;  
```  
  
**index.py 中的自动化监控**（[`scripts/index.py` 190-208]()）：  
  
Python 脚本使用 asyncio 并发监控构建进度：  
- 从 `pg_stat_progress_create_index.blocks_total` 获取总块数（[`index.py` 193-197]()）；  
- 使用 `tqdm` 显示总块数的进度条（[`index.py` 198]()）；  
- 每秒读取 `blocks_done` 直到构建完成（[`index.py` 199-207]()）；  
- 构建任务通过 `asyncio.Event` 发出完成信号（[`index.py` 200-202]()）。  
  
构建任务（[`index.py` 176-188]()）通过 `max_parallel_maintenance_workers` GUC 设置并行工作进程数（[`index.py` 181-182]()），并使用 TOML 选项字符串执行 `CREATE INDEX`（[`index.py` 183-185]()）。  
  
来源:    
[`src/index/functions.rs` 22-63](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/functions.rs#L22-L63)    
[`scripts/index.py` 176-208](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/index.py#L176-L208)  
  
  
  
## 性能基准测试  
  
**VectorChord** 包含基准测试脚本（`scripts/bench.py`），用于测量召回率（Recall）、QPS（每秒查询数）、延迟百分位数（latency percentiles）。  
  
### 运行基准测试  
```  
# Single-threaded benchmark with progress bar  
python scripts/bench.py \  
  -n documents \  
  -i dataset.hdf5 \  
  -m l2 \  
  --nprob 100 \  
  --epsilon 1.0 \  
  --url postgresql://user:pass@localhost:5432/dbname  
  
# Multi-process benchmark for maximum QPS measurement  
python scripts/bench.py \  
  -n documents \  
  -i dataset.hdf5 \  
  -m l2 \  
  --nprob 100 \  
  --epsilon 1.0 \  
  --processes 8 \  
  --url postgresql://user:pass@localhost:5432/dbname  
```  
  
  
#### 基准测试指标  
  
| 指标（Metric） | 计算方式 | 实现位置 |  
|---|---|---|  
| Recall（召回率） | `hits / (k * num_queries)` | 通过结果 ID 与真实近邻对比（[`bench.py` 128-130, 153]()） |  
| QPS | `num_queries / total_time` | 并行模式下使用 `calculate_coverage()` 合并重叠时间区间（[`bench.py` 90-108, 154]()） |  
| P50 延迟 | 50% 分位数 | `np.percentile(latencies_ms, 50)`（[`bench.py` 158]()） |  
| P99 延迟 | 99% 分位数 | `np.percentile(latencies_ms, 99)`（[`bench.py` 159]()） |  
  
  
#### 顺序基准测试 (Sequential Benchmark)（[`bench.py` 201-233]()）：  
  
* 使用 `create_connection()` 创建的**单一连接** (single connection) ([`bench.py` 58-87]())  
* 使用 `tqdm` **进度条** (progress bar) 迭代测试查询 ([`bench.py` 205]())  
* 执行查询 (Executes query): `SELECT id FROM {name} ORDER BY embedding {metric_ops} %s LIMIT {k}` ([`bench.py` 208-210]())  
* 通过**集合交集** (set intersection) 计算命中数 (hit count): `set(result_ids) & set(ground_truth_ids)` ([`bench.py` 215]())  
* 使用运行中的指标 (running metrics) 更新进度条 ([`bench.py` 219-222]())  
  
  
#### 并行基准测试 (Parallel Benchmark) （[`bench.py` 164-199]()）：  
  
* 使用指定数量的进程 (processes) 创建 `multiprocessing.Pool` ([`bench.py` 185]())  
* 每个进程使用**其自己的连接** (its own connection) 运行 `process_batch()` ([`bench.py` 110-136]())  
* **聚合** (Aggregates) 所有批次 (batches) 的结果 ([`bench.py` 189]())  
* 使用 `calculate_coverage()` 从重叠的时间间隔 (overlapping intervals) 中计算总时间 ([`bench.py` 145]())  
  
来源:    
[`scripts/bench.py` 1-267](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L1-L267)    
[`scripts/README.md` 54-58](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L54-L58)  
  
### 结果解读示例  
  
```  
Top: 10  
  Recall: 0.9520  
  QPS: 847.32  
  P50 latency: 11.23ms  
  P99 latency: 18.47ms  
```  
  
#### 指标解读  
  
- `Recall ≥ 0.95`: 召回率 = `match_count / (k * num_queries)`（[`bench.py` 153]()）；  
- `QPS`: 每秒查询次数。数值越高越好；取决于硬件、并发性和索引参数. 使用 `calculate_coverage()` 处理查询执行时间重叠（[`bench.py` 90-108]()）；  
- `P50 Latency`: 查询时间的中位数。代表典型的用户体验。 计算方法 `np.percentile(latencies_ms, 50)`（[`bench.py` 158]()）。  
- `P99 Latency`: 99百分位查询时间。代表 1% 查询的最坏情况体验。对 SLA 保证至关重要（[`bench.py` 159]()）。  
  
#### 连接调优（[`bench.py` 58-87]()）：  
  
基准测试建立连接时设置：  
- PostgreSQL keepalive settings: `keepalives=1, keepalives_idle=30, keepalives_interval=5, keepalives_count=5`（[`bench.py` 59-63]()）；  
- JIT disabled: `SET jit=false`（[`bench.py` 77]()）避免 JIT 编译开销；  
- I/O concurrency: `SET effective_io_concurrency=200`（[`bench.py` 78]()）提升预取性能；  
- Index parameters: `SET vchordrq.probes={nprob}`, `SET vchordrq.epsilon={epsilon}`（[`bench.py` 80-81]()）；  
- Optional pre-warming: `SELECT vchordrq_prewarm('{name}_embedding_idx'::regclass)`（[`bench.py` 83]()）。  
  
  
来源:    
[`scripts/bench.py` 1-267](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/bench.py#L1-L267)    
[`scripts/README.md` 54-58](https://github.com/tensorchord/VectorChord/blob/ac12e257/scripts/README.md#L54-L58)  
  
  
  
## 常见生产模式  
  
### 模式 1：带过滤的混合搜索（Hybrid Search with Filtering）  
```  
-- Enable prefiltering for WHERE clauses  
SET vchordrq.prefilter = true;  
  
-- Query with metadata filters  
SELECT id, title, content,   
       embedding <-> '[...]'::vector AS distance  
FROM documents  
WHERE category = 'technology'  
  AND published_date > '2024-01-01'  
ORDER BY embedding <-> '[...]'::vector  
LIMIT 10;  
```  
  
`prefilter` 选项由 [`src/index/gucs.rs` 70](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L70-L70) 控制，在有益时于索引扫描前应用过滤条件。  
  
### 模式 2：使用球体的范围查询（Range Queries with Spheres）  
```  
-- Find all vectors within distance threshold  
SELECT id, content  
FROM documents  
WHERE embedding <<->> sphere('[...]'::vector, 0.5)  
ORDER BY embedding <-> '[...]'::vector  
LIMIT 100;  
```  
  
球体操作符可在排序前按距离阈值过滤，详见 [`src/sql/finalize.sql` 53-114](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L53-L114)。  
  
### 模式 3：自适应参数调优（Adaptive Parameter Tuning）  
```  
-- Start with conservative parameters  
SET vchordrq.probes = '100';  
SET vchordrq.epsilon = 1.5;  
  
-- Query and measure recall  
SELECT * FROM documents ORDER BY embedding <-> '[...]'::vector LIMIT 10;  
SELECT vchordrq_evaluate_query_recall('SELECT ctid FROM documents ORDER BY embedding <-> ''[...]'' LIMIT 10');  
  
-- Adjust parameters based on recall  
SET vchordrq.probes = '200';  -- Increase probes if recall < 0.95  
SET vchordrq.epsilon = 2.0;    -- Increase epsilon for higher recall  
```  
  
该迭代方法平衡延迟与召回率。  
  
### 模式 4：多向量检索（MaxSim）  
```  
-- Store token embeddings for documents  
CREATE TABLE documents_maxsim (  
    id BIGSERIAL PRIMARY KEY,  
    token_embeddings vector(768)[]  
);  
  
-- Create MaxSim index  
CREATE INDEX ON documents_maxsim   
USING vchordrq (token_embeddings vector_maxsim_ops);  
  
-- Query with MaxSim  
SELECT id,   
       token_embeddings @# ARRAY['[...]'::vector, '[...]'::vector] AS score  
FROM documents_maxsim  
ORDER BY token_embeddings @# ARRAY['[...]'::vector, '[...]'::vector]  
LIMIT 10;  
```  
  
MaxSim 操作符计算 token 对之间的最大相似度，适用于晚期交互模型（late-interaction models），详见 [`src/sql/finalize.sql` 116-127](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L116-L127)。  
  
来源:    
[`src/index/gucs.rs` 70](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/index/gucs.rs#L70-L70)    
[`src/sql/finalize.sql` 53-127](https://github.com/tensorchord/VectorChord/blob/ac12e257/src/sql/finalize.sql#L53-L127)    
[`README.md` 110-112](https://github.com/tensorchord/VectorChord/blob/ac12e257/README.md#L110-L112)  
    
  
  
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
