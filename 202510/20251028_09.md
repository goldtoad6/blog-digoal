## Milvus 为什么使用基于任务的查询处理架构? 有什么优势? 有什么潜在性能问题?   
                                            
### 作者                                           
digoal                                          
                                         
### 日期                                        
2025-10-28                                        
                                          
### 标签                                          
Milvus , task-based query processing , 队列 , 任务调度 , 分布式 , 节点间通信                                            
                                          
----                                          
                                          
## 背景    
Milvus 为什么采用 task-based 的查询处理架构, 这个架构有何特点? 如果采用消费队列的形式执行, 执行过程会不会有延迟和性能问题?   
  
## 为什么采用 Task-Based 架构  
  
Milvus 采用 task-based 架构主要是为了统一处理不同类型的操作(DDL、DML、查询)并提供一致的生命周期管理。 所有操作都实现了 `task` 接口,包括 `PreExecute()`、`Execute()` 和 `PostExecute()` 三个核心方法。   
  
这种设计允许 Proxy 服务将客户端请求转换为内部任务,然后通过专门的任务队列进行调度。具体来说,有三种任务队列:  
- `ddQueue` - 处理 DDL 任务(如创建集合)  
- `dmQueue` - 处理 DML 任务(如插入、删除)  
- `dqQueue` - 处理查询任务(如搜索、检索)  
  
## 架构特点  
  
### 1. 统一的任务生命周期  
  
每个任务都遵循相同的执行流程:   
- **PreExecute**: 验证请求参数、获取集合 schema、生成执行计划  
- **Execute**: 通过 QueryCoordV2 分发任务到 QueryNode  
- **PostExecute**: 聚合结果、应用后处理  
  
### 2. 分布式任务调度  
  
QueryCoordV2 使用 `taskScheduler` 管理跨节点的任务执行。 调度器维护多个队列(`waitQueue`、`processQueue`)和执行器映射,支持任务的优先级调度和并行执行。   
  
### 3. 任务类型多样性  
  
不同的查询操作有专门的任务实现:  
- `searchTask` - 处理向量相似度搜索    
- `queryTask` - 处理数据检索    
  
## 延迟和性能考虑  
  
### 1. 任务调度延迟  
  
任务需要经过入队、调度、执行等多个阶段。 从代码可以看到, 任务入队后需要调用 `qt.WaitToFinish()` 等待完成, 这会引入一定的调度延迟。   
  
### 2. 性能优化措施  
  
**并行执行**: 调度器支持并行处理多个任务。 在 `schedule()` 方法中, 使用 `funcutil.ProcessFuncParallel` 并行处理任务,以提高吞吐量。   
  
**批量处理**: QueryNode 层面,任务通过调度器批量执行。 任务被添加到 `node.scheduler` 后, 通过 `task.Wait()` 等待执行完成。   
  
**结果聚合优化**: 查询任务使用 `resultBuf` 收集部分结果。 执行阶段通过负载均衡策略(`lb.Execute`)分发到多个 QueryNode, 然后在 PostExecute 阶段聚合结果。   
  
### 3. 潜在性能瓶颈  
  
**任务队列等待**: 如果任务队列积压, 会增加等待时间。调度器会记录队列长度指标(`processingTaskNum`、`waitingTaskNum`)来监控这个问题。    
  
**跨节点通信**: 任务需要在 Proxy、QueryCoord 和 QueryNode 之间传递,网络延迟不可避免。   
  
**结果聚合开销**: 对于大规模查询, 从多个节点收集和聚合结果需要额外的处理时间。    
  
## 注意  
  
Task-based 架构的主要优势是提供了统一、可扩展的请求处理框架,支持复杂的调度策略和并行执行。虽然引入了一定的调度开销, 但通过并行处理、批量执行等优化措施, 整体性能是可控的。 系统通过详细的 metrics 监控(如 `ProxySQLatency`、`QueryNodeSQReqLatency`)来跟踪各阶段的延迟, 便于识别和优化性能瓶颈。   
      
#### [期望 PostgreSQL|开源PolarDB 增加什么功能?](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
  
  
#### [PolarDB 开源数据库](https://openpolardb.com/home "57258f76c37864c6e6d23383d05714ea")
  
  
#### [PolarDB 学习图谱](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
  
  
#### [PostgreSQL 解决方案集合](../201706/20170601_02.md "40cff096e9ed7122c512b35d8561d9c8")
  
  
#### [德哥 / digoal's Github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
  
  
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")
  
  
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
  
